<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ranking Stability Check</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; max-width: 1100px; }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin-top: 14px; }
    .muted { color: #555; }
    .big { font-size: 1.15rem; line-height: 1.35; }
    label { display: inline-block; }
    input[type="range"] { width: 360px; }
    input[type="number"] { width: 110px; }
    select { padding: 4px 6px; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; vertical-align: top; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 920px) { .grid { grid-template-columns: 1fr; } }
    canvas { width: 100%; height: 220px; border: 1px solid #eee; border-radius: 10px; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 0.9rem; margin-right: 8px; }
    .warn { color: #7a4b00; }
    .ok { color: #0b6a2b; }
    .err { color: #8a1f1f; }
  </style>
</head>
<body>
  <h1>Ranking Stability Check</h1>
  <p class="muted">
    Upload a CSV and sanity-check whether the ranking is robust. All computation runs locally in your browser.
    This is a robustness test, not a claim about true uncertainty.
  </p>

  <div class="card">
    <div class="row">
      <input id="file" type="file" accept=".csv,text/csv" />
      <span class="muted">Expected headers like <code>item</code> and <code>score</code>, but you can map columns below.</span>
    </div>

    <div id="mapRow" class="row" style="margin-top: 12px; display:none;">
      <label>Item column<br><select id="itemCol"></select></label>
      <label>Score column<br><select id="scoreCol"></select></label>
      <label>Rows to preview<br><input id="previewN" type="number" min="5" max="200" step="5" value="25"></label>
      <button id="applyMap">Apply</button>
      <span id="parseStatus" class="muted"></span>
    </div>
  </div>

  <div id="controls" class="card" style="display:none;">
    <div class="row">
      <label>Top-k cutoff<br>
        <input id="k" type="number" min="1" step="1" value="5">
      </label>

      <label>ε (score wiggle room)<br>
        <input id="eps" type="range" min="0" max="1" step="0.001" value="0">
      </label>
      <div>
        <div>ε: <strong id="epsLabel">0.000</strong></div>
        <div class="muted">or <span id="epsPct">0.00%</span> of score range</div>
      </div>

      <label>ε as % of score range<br>
        <input id="epsPctInput" type="number" min="0" max="200" step="0.1" value="0">
      </label>

      <button id="exportJson">Export JSON</button>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:14px 0;">

    <div class="row">
      <label><input id="mcEnable" type="checkbox"> Monte Carlo mode</label>
      <label>Samples<br><input id="mcN" type="number" min="200" max="20000" step="200" value="2000" disabled></label>
      <label>Seed<br><input id="mcSeed" type="number" min="0" max="999999999" step="1" value="12345" disabled></label>
      <button id="runMc" disabled>Run Monte Carlo</button>
      <span class="muted">Optional. Deterministic breakpoints are computed instantly.</span>
    </div>
  </div>

  <div id="out" class="card" style="display:none;">
    <div id="headline" class="big"></div>
    <p id="sub" class="muted"></p>

    <div class="grid">
      <div class="card" style="margin-top:0;">
        <h3>Breakpoints</h3>
        <table id="bpTable"></table>
      </div>
      <div class="card" style="margin-top:0;">
        <h3>Clusters at ε = <span id="epsLabel2">0.000</span></h3>
        <div id="clusters"></div>
      </div>
    </div>

    <div class="grid">
      <div class="card" style="margin-top:0;">
        <h3>Scores (sorted)</h3>
        <canvas id="scorePlot" width="1000" height="260"></canvas>
        <p class="muted">Each point is an item. Tight packing suggests fragile ordering.</p>
      </div>
      <div class="card" style="margin-top:0;">
        <h3>Adjacent gaps</h3>
        <canvas id="gapPlot" width="1000" height="260"></canvas>
        <p class="muted">Gaps below <code>2ε</code> indicate adjacent items can swap under ±ε perturbations.</p>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <h3>Preview (sorted)</h3>
      <table id="preview"></table>
    </div>

    <div id="mcOut" class="card" style="display:none;">
      <h3>Monte Carlo results</h3>
      <p id="mcSummary" class="big"></p>

      <div class="grid">
        <div class="card" style="margin-top:0;">
          <h4>Top-k stability</h4>
          <table id="mcTopKTable"></table>
          <p class="muted">
            <strong>Top-k set unchanged</strong> is the fraction of simulations where the selected top-k items exactly match the original top-k.
            <br>
            <strong>Avg overlap</strong> is the average fraction of original top-k items still present in the simulated top-k.
          </p>
        </div>
        <div class="card" style="margin-top:0;">
          <h4>Per-item movement (first 30)</h4>
          <table id="mcMoveTable"></table>
          <p class="muted">Same-rank % refers to the item staying in its original rank position, not merely staying within the top-k.</p>
        </div>
      </div>

      <div class="card" style="margin-top:14px;">
        <h4>Top-k inclusion probabilities (first 30 by original rank)</h4>
        <table id="mcInclTable"></table>
        <p class="muted">P(in Top-k) is the fraction of simulations in which the item appears in the simulated Top-k.</p>
      </div>

      <p class="muted">Monte Carlo assumes independent uniform noise in ±ε. Use it as a stress test, not a truth claim.</p>
    </div>
  </div>

  <script>
    // ---------------------------
    // Robust CSV parsing (quoted fields supported)
    // ---------------------------
    function parseCSVRobust(text) {
      const rows = [];
      let row = [];
      let field = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const c = text[i];

        if (inQuotes) {
          if (c === '"') {
            const next = text[i + 1];
            if (next === '"') {
              field += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            field += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            row.push(field);
            field = "";
          } else if (c === "\n") {
            row.push(field);
            field = "";
            rows.push(row);
            row = [];
          } else if (c === "\r") {
            // ignore
          } else {
            field += c;
          }
        }
      }
      row.push(field);
      rows.push(row);

      const cleaned = rows
        .map(r => r.map(x => (x ?? "").trim()))
        .filter(r => r.some(x => x !== ""));

      if (cleaned.length < 2) throw new Error("CSV must have a header row and at least one data row.");
      return cleaned;
    }

    function toLowerTrim(s) {
      return (s ?? "").toString().trim().toLowerCase();
    }

    function guessColumn(headers, candidates) {
      const lower = headers.map(toLowerTrim);
      for (const c of candidates) {
        const idx = lower.indexOf(c);
        if (idx !== -1) return idx;
      }
      return -1;
    }

    function safeNumber(x) {
      if (x == null) return null;
      const s = x.toString().trim();
      if (!s) return null;
      const n = Number(s.replace(/,/g, ""));
      return Number.isFinite(n) ? n : null;
    }

    function sortDesc(rows) {
      return [...rows].sort((a, b) => b.score - a.score);
    }

    function computeBreakpoints(sorted) {
      const n = sorted.length;
      const gaps = [];
      for (let i = 0; i < n - 1; i++) {
        gaps.push(sorted[i].score - sorted[i + 1].score);
      }
      const epsAnyFlip = Math.min(...gaps) / 2;

      const topK = [1, 3, 5, 10, 20].filter(k => k < n);
      const epsTopK = topK.map(k => ({
        k,
        eps: (sorted[k - 1].score - sorted[k].score) / 2
      }));

      return { gaps, epsAnyFlip, epsTopK };
    }

    function clustersAtEps(sorted, eps) {
      const clusters = [];
      let current = [sorted[0]];
      for (let i = 0; i < sorted.length - 1; i++) {
        const gap = sorted[i].score - sorted[i + 1].score;
        if (gap <= 2 * eps) current.push(sorted[i + 1]);
        else { clusters.push(current); current = [sorted[i + 1]]; }
      }
      clusters.push(current);
      return clusters;
    }

    function fmt(x) {
      if (!Number.isFinite(x)) return "n/a";
      const ax = Math.abs(x);
      if (ax >= 100) return x.toFixed(1);
      if (ax >= 1) return x.toFixed(3);
      return x.toFixed(4);
    }

    function renderTable(el, headers, rows) {
      el.innerHTML = "";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      el.appendChild(thead);

      const tbody = document.createElement("tbody");
      rows.forEach(r => {
        const tr = document.createElement("tr");
        r.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      el.appendChild(tbody);
    }

    function clamp(x, a, b) {
      return Math.max(a, Math.min(b, x));
    }

    // ---------------------------
    // Simple plotting helpers (canvas)
    // ---------------------------
    function drawPlot(canvas, ys, opts) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      const padL = 52, padR = 16, padT = 16, padB = 36;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;

      const n = ys.length;
      const yMin = Math.min(...ys);
      const yMax = Math.max(...ys);
      const ySpan = (yMax - yMin) || 1;

      ctx.strokeStyle = "#999";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + innerH);
      ctx.lineTo(padL + innerW, padT + innerH);
      ctx.stroke();

      ctx.fillStyle = "#444";
      ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(opts.yLabel || "", 8, 18);
      ctx.fillText(opts.xLabel || "", padL + innerW - 110, padT + innerH + 26);

      const ticks = 4;
      for (let t = 0; t <= ticks; t++) {
        const y = padT + innerH - (t / ticks) * innerH;
        const v = yMin + (t / ticks) * ySpan;
        ctx.strokeStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(padL, y);
        ctx.lineTo(padL + innerW, y);
        ctx.stroke();

        ctx.fillStyle = "#666";
        ctx.fillText(fmt(v), 10, y + 5);
      }

      ctx.fillStyle = "#111";
      for (let i = 0; i < n; i++) {
        const x = padL + (n === 1 ? innerW / 2 : (i / (n - 1)) * innerW);
        const y = padT + innerH - ((ys[i] - yMin) / ySpan) * innerH;
        ctx.beginPath();
        ctx.arc(x, y, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }

      if (opts.threshold != null) {
        const tv = opts.threshold;
        const y = padT + innerH - ((tv - yMin) / ySpan) * innerH;
        ctx.strokeStyle = "#b66";
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(padL, y);
        ctx.lineTo(padL + innerW, y);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = "#b66";
        ctx.fillText(opts.thresholdLabel || "threshold", padL + 6, clamp(y - 6, 14, h - 10));
      }
    }

    // ---------------------------
    // Monte Carlo (optional)
    // ---------------------------
    function mulberry32(seed) {
      let a = seed >>> 0;
      return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // Updated: includes exact Top-k stability metrics
    function runMonteCarlo(sorted, eps, nSamp, seed, k) {
      const rng = mulberry32(seed);
      const n = sorted.length;

      // Original Top-k set
      const topK0 = new Set(sorted.slice(0, k).map(r => r.item));
      let topKSetSameCount = 0;
      let topKOverlapSum = 0;

      // Per-item inclusion in top-k
      const topKInCount = new Map();
      sorted.forEach(r => topKInCount.set(r.item, 0));

      // Track per item: count same rank, min rank, max rank, sum abs displacement
      const stats = new Map();
      sorted.forEach((r, i) => {
        stats.set(r.item, { origRank: i + 1, same: 0, minRank: i + 1, maxRank: i + 1, sumAbs: 0 });
      });

      let inversionCount = 0;
      const totalPairs = n * (n - 1) / 2;

      for (let s = 0; s < nSamp; s++) {
        const pert = sorted.map(r => {
          const u = rng();
          const delta = (u * 2 - 1) * eps; // uniform in [-eps, eps]
          return { item: r.item, score: r.score + delta };
        }).sort((a, b) => b.score - a.score);

        // Top-k set in this simulation
        const topKt = pert.slice(0, k).map(r => r.item);
        const topKtSet = new Set(topKt);

        // (A) Top-k set unchanged
        if (topKtSet.size === topK0.size) {
          let same = true;
          for (const it of topK0) {
            if (!topKtSet.has(it)) { same = false; break; }
          }
          if (same) topKSetSameCount++;
        }

        // (B) Overlap fraction
        let overlap = 0;
        for (const it of topKtSet) {
          if (topK0.has(it)) overlap++;
        }
        topKOverlapSum += overlap;

        // (C) Per-item inclusion counts
        for (const it of topKtSet) {
          topKInCount.set(it, topKInCount.get(it) + 1);
        }

        // Per-item ranks in this simulation
        const rankByItem = new Map();
        pert.forEach((r, idx) => rankByItem.set(r.item, idx + 1));

        // Per-item movement stats
        pert.forEach((r, idx) => {
          const st = stats.get(r.item);
          const rk = idx + 1;
          if (rk === st.origRank) st.same++;
          st.minRank = Math.min(st.minRank, rk);
          st.maxRank = Math.max(st.maxRank, rk);
          st.sumAbs += Math.abs(rk - st.origRank);
        });

        // Inversions relative to original order (O(n^2), only for small n)
        if (n <= 200) {
          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const itemI = sorted[i].item;
              const itemJ = sorted[j].item;
              if (rankByItem.get(itemI) > rankByItem.get(itemJ)) inversionCount++;
            }
          }
        }
      }

      const rows = [];
      stats.forEach((st, item) => {
        rows.push({
          item,
          origRank: st.origRank,
          stability: st.same / nSamp,
          avgAbsMove: st.sumAbs / nSamp,
          minRank: st.minRank,
          maxRank: st.maxRank
        });
      });
      rows.sort((a, b) => a.origRank - b.origRank);

      let inversionRate = null;
      if (n <= 200) inversionRate = inversionCount / (nSamp * totalPairs);

      const topK = {
        k,
        setSameProb: topKSetSameCount / nSamp,
        avgOverlapFrac: (topKOverlapSum / nSamp) / k,
        inclusionProb: Array.from(topKInCount.entries())
          .map(([item, cnt]) => ({ item, prob: cnt / nSamp }))
          .sort((a, b) => b.prob - a.prob)
      };

      return { rows, inversionRate, nSamp, seed, eps, topK };
    }

    // ---------------------------
    // UI wiring
    // ---------------------------
    const fileInput = document.getElementById("file");
    const mapRow = document.getElementById("mapRow");
    const itemColSel = document.getElementById("itemCol");
    const scoreColSel = document.getElementById("scoreCol");
    const applyMapBtn = document.getElementById("applyMap");
    const parseStatus = document.getElementById("parseStatus");
    const previewN = document.getElementById("previewN");

    const controls = document.getElementById("controls");
    const kInput = document.getElementById("k");
    const epsSlider = document.getElementById("eps");
    const epsLabel = document.getElementById("epsLabel");
    const epsLabel2 = document.getElementById("epsLabel2");
    const epsPct = document.getElementById("epsPct");
    const epsPctInput = document.getElementById("epsPctInput");
    const exportJsonBtn = document.getElementById("exportJson");

    const mcEnable = document.getElementById("mcEnable");
    const mcN = document.getElementById("mcN");
    const mcSeed = document.getElementById("mcSeed");
    const runMcBtn = document.getElementById("runMc");

    const out = document.getElementById("out");
    const headline = document.getElementById("headline");
    const sub = document.getElementById("sub");
    const bpTable = document.getElementById("bpTable");
    const clustersDiv = document.getElementById("clusters");
    const previewTable = document.getElementById("preview");
    const scorePlot = document.getElementById("scorePlot");
    const gapPlot = document.getElementById("gapPlot");

    const mcOut = document.getElementById("mcOut");
    const mcSummary = document.getElementById("mcSummary");
    const mcTopKTable = document.getElementById("mcTopKTable");
    const mcMoveTable = document.getElementById("mcMoveTable");
    const mcInclTable = document.getElementById("mcInclTable");

    let rawGrid = null;
    let headers = null;
    let dataRows = null;
    let state = null;

    function fillSelect(selectEl, headers) {
      selectEl.innerHTML = "";
      headers.forEach((h, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = h || `(col ${idx + 1})`;
        selectEl.appendChild(opt);
      });
    }

    function computeFromMapping(itemIdx, scoreIdx) {
      const rows = [];
      for (const r of dataRows) {
        const item = (r[itemIdx] ?? "").toString().trim();
        const score = safeNumber(r[scoreIdx]);
        if (!item) continue;
        if (score == null) continue;
        rows.push({ item, score });
      }
      if (rows.length < 2) throw new Error("Need at least two valid rows with non-empty item and numeric score.");

      const sorted = sortDesc(rows);

      const scores = sorted.map(r => r.score);
      const min = Math.min(...scores);
      const max = Math.max(...scores);
      const range = (max - min) || 1;

      const bps = computeBreakpoints(sorted);

      return { rows, sorted, scores, min, max, range, bps };
    }

    function updateEpsControls() {
      const maxEps = Math.max(state.range / 2, state.range * 0.05, 1e-6);
      epsSlider.min = "0";
      epsSlider.max = String(maxEps);
      epsSlider.step = String(maxEps / 500);
      const current = Number(epsSlider.value) || 0;
      epsSlider.value = String(clamp(current, 0, maxEps));

      const eps = Number(epsSlider.value);
      const pct = (eps / state.range) * 100;
      epsPctInput.value = String(pct.toFixed(2));

      updateOutputs();
    }

    function currentK() {
      const n = state.sorted.length;
      const k = clamp(Math.floor(Number(kInput.value) || 1), 1, n - 1);
      kInput.value = String(k);
      return k;
    }

    function updateOutputs() {
      if (!state) return;
      const eps = Number(epsSlider.value) || 0;
      epsLabel.textContent = fmt(eps);
      epsLabel2.textContent = fmt(eps);
      epsPct.textContent = ((eps / state.range) * 100).toFixed(2) + "%";

      const k = currentK();
      const epsTopK = (state.sorted[k - 1].score - state.sorted[k].score) / 2;

      const badge = epsTopK <= eps ? `<span class="pill warn">At ε this cutoff is unstable</span>` : `<span class="pill ok">At ε this cutoff is stable</span>`;
      headline.innerHTML = `${badge} Top-${k} membership is only defensible if your scoring is accurate to within ±${fmt(epsTopK)}.`;
      sub.textContent =
        `Interpretation: if you cannot honestly defend score precision better than ±${fmt(epsTopK)}, treat ranks around the cutoff as tied or gather better data.`;

      const bpRows = [
        ["Minimum ε to flip any adjacent pair", fmt(state.bps.epsAnyFlip)],
        ["ε to break Top-" + k + " membership (k vs k+1)", fmt(epsTopK)],
        ...state.bps.epsTopK.map(x => [`ε to break Top-${x.k} membership`, fmt(x.eps)])
      ];
      renderTable(bpTable, ["Breakpoint", "ε"], bpRows);

      const cl = clustersAtEps(state.sorted, eps);
      clustersDiv.innerHTML = cl.map((c, idx) => {
        const ranks = c.map(x => state.sorted.indexOf(x) + 1);
        const from = Math.min(...ranks);
        const to = Math.max(...ranks);
        const items = c.map(x => x.item).join(", ");
        return `<p><strong>Cluster ${idx + 1} (ranks ${from}–${to})</strong><br>${items}</p>`;
      }).join("");

      const nPrev = clamp(Math.floor(Number(previewN.value) || 25), 5, 200);
      renderTable(
        previewTable,
        ["Rank", "Item", "Score"],
        state.sorted.slice(0, nPrev).map((r, i) => [String(i + 1), r.item, String(r.score)])
      );

      drawPlot(scorePlot, state.scores, { yLabel: "score", xLabel: "rank" });

      const gaps = state.bps.gaps;
      drawPlot(gapPlot, gaps, { yLabel: "gap", xLabel: "adjacent pair", threshold: 2 * eps, thresholdLabel: "2ε" });

      mcOut.style.display = "none";
    }

    function enableMcUI(enabled) {
      mcN.disabled = !enabled;
      mcSeed.disabled = !enabled;
      runMcBtn.disabled = !enabled;
      if (!enabled) mcOut.style.display = "none";
    }

    function exportJSON() {
      const eps = Number(epsSlider.value) || 0;
      const k = currentK();
      const epsTopK = (state.sorted[k - 1].score - state.sorted[k].score) / 2;

      const result = {
        meta: {
          generated_at: new Date().toISOString(),
          note: "Robustness check. Computed breakpoints are properties of the score spacing, not estimates of true uncertainty.",
        },
        input: {
          n_items: state.sorted.length,
          top_k: k,
          eps_current: eps,
          eps_current_pct_of_range: (eps / state.range) * 100,
        },
        breakpoints: {
          eps_any_adjacent_flip: state.bps.epsAnyFlip,
          eps_break_top_k: epsTopK,
          eps_break_top_k_standard: state.bps.epsTopK,
        },
        clusters_at_eps: clustersAtEps(state.sorted, eps).map(cluster => cluster.map(x => x.item)),
        top_items_preview: state.sorted.slice(0, 25),
      };

      const blob = new Blob([JSON.stringify(result, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "ranking_stability_result.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // File load and mapping
    fileInput.addEventListener("change", async () => {
      const file = fileInput.files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        rawGrid = parseCSVRobust(text);
        headers = rawGrid[0];
        dataRows = rawGrid.slice(1);

        fillSelect(itemColSel, headers);
        fillSelect(scoreColSel, headers);

        const itemGuess = guessColumn(headers, ["item", "name", "label", "id", "candidate", "vendor"]);
        const scoreGuess = guessColumn(headers, ["score", "value", "rating", "points", "rank_score", "total"]);

        if (itemGuess !== -1) itemColSel.value = String(itemGuess);
        if (scoreGuess !== -1) scoreColSel.value = String(scoreGuess);

        mapRow.style.display = "flex";
        parseStatus.textContent = `Loaded ${dataRows.length} rows, ${headers.length} columns. Map columns and click Apply.`;
        parseStatus.className = "muted";
      } catch (err) {
        alert(err?.message || String(err));
        mapRow.style.display = "none";
        controls.style.display = "none";
        out.style.display = "none";
        state = null;
      }
    });

    applyMapBtn.addEventListener("click", () => {
      try {
        const itemIdx = Number(itemColSel.value);
        const scoreIdx = Number(scoreColSel.value);

        state = computeFromMapping(itemIdx, scoreIdx);

        controls.style.display = "block";
        out.style.display = "block";

        kInput.max = String(Math.max(1, state.sorted.length - 1));
        kInput.value = String(clamp(Number(kInput.value) || 5, 1, Math.max(1, state.sorted.length - 1)));

        updateEpsControls();
        enableMcUI(mcEnable.checked);

        parseStatus.textContent = `Parsed ${state.sorted.length} valid rows.`;
        parseStatus.className = "muted";
      } catch (err) {
        parseStatus.textContent = err?.message || String(err);
        parseStatus.className = "muted err";
        controls.style.display = "none";
        out.style.display = "none";
        state = null;
      }
    });

    // Controls
    kInput.addEventListener("input", () => updateOutputs());

    epsSlider.addEventListener("input", () => updateOutputs());

    epsPctInput.addEventListener("input", () => {
      if (!state) return;
      const pct = Number(epsPctInput.value);
      const eps = (pct / 100) * state.range;
      epsSlider.value = String(clamp(eps, 0, Number(epsSlider.max)));
      updateOutputs();
    });

    exportJsonBtn.addEventListener("click", () => {
      if (!state) return;
      exportJSON();
    });

    mcEnable.addEventListener("change", () => enableMcUI(mcEnable.checked));

    runMcBtn.addEventListener("click", () => {
      if (!state) return;
      const eps = Number(epsSlider.value) || 0;
      const nSamp = clamp(Math.floor(Number(mcN.value) || 2000), 200, 20000);
      const seed = clamp(Math.floor(Number(mcSeed.value) || 12345), 0, 999999999);
      const k = currentK();

      const mc = runMonteCarlo(state.sorted, eps, nSamp, seed, k);

      const setSamePct = (mc.topK.setSameProb * 100).toFixed(1);
      const overlapPct = (mc.topK.avgOverlapFrac * 100).toFixed(1);

      const invPart = (mc.inversionRate == null)
        ? "Inversion rate skipped (list too large)."
        : `Average pair inversion rate: ${(mc.inversionRate * 100).toFixed(2)}%.`;

      mcSummary.textContent =
        `Monte Carlo stress test at ε = ${fmt(eps)} with ${nSamp} samples (seed ${seed}). ` +
        `Top-${k} set unchanged: ${setSamePct}%. Avg Top-${k} overlap: ${overlapPct}%. ` +
        invPart;

      renderTable(mcTopKTable, ["Metric", "Value"], [
        [`Top-${k} set unchanged`, `${setSamePct}%`],
        [`Avg Top-${k} overlap`, `${overlapPct}%`],
      ]);

      const moveRows = mc.rows.slice(0, 30).map(r => [
        String(r.origRank),
        r.item,
        (r.stability * 100).toFixed(1) + "%",
        fmt(r.avgAbsMove),
        `${r.minRank}–${r.maxRank}`
      ]);
      renderTable(mcMoveTable, ["Orig rank", "Item", "Same-rank %", "Avg |move|", "Observed rank range"], moveRows);

      const inclByOrigRank = mc.rows.slice(0, 30).map(r => {
        const p = mc.topK.inclusionProb.find(x => x.item === r.item)?.prob ?? 0;
        return [String(r.origRank), r.item, (p * 100).toFixed(1) + "%"];
      });
      renderTable(mcInclTable, ["Orig rank", "Item", `P(in Top-${k})`], inclByOrigRank);

      mcOut.style.display = "block";
    });
  </script>
</body>
</html>
